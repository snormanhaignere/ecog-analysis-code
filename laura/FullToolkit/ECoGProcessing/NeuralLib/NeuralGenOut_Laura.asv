function out = NeuralGenOut_Laura(datapath, cond, subject, blocks, channels, dataf, befaft, specflag, datatype, artifact)
% evnt is the event strcutre from NeuralFindEvents
% cond is the data condition, e.g. raw, afterICA, ...
% elects is the electrode numbers to be used
% befaft: how much of the data before and after the stimulus to be included
% dataf: out data sampling frequency
% specflag: what type of spectrogram, options: Auditory
% artifact: artifacts that you want to add and are included in artifact
% folder

% This version adapted by Laura 11/2015;
% - function no longer takes an evnt input; instead, it asks for blocks and loads
% the appropriate evnt acccordingly. Allows looping over several blocks at
% once, and is more consistent with evnt code inputs.
% - adjusted for new ECoG Data organization (processed folder)
% - added option to save out if desired
% - added lots of comments
% - revised blocks input to be valid as matrix or cell
% - out saves to each block folder
% - changed variable names (to lowercase, switched input order to be
% consistent with Convert/Out functions)

%% Deal with Inputs

% Check if datapath was entered; if not, default to current directory
if ~exist('datapath','var') || isempty(datapath)
    datapath = pwd;
end

% Check if cond was entered; if not, default to htkraw
if ~exist('cond','var') || isempty(cond)
    cond = 'htkraw';
end

% Check if blocks was entered; if not, default to
if ~exist('blocks','var') || isempty(blocks)
    blocks = [];
end
if iscell(blocks) % If blocks input is matrix, turn it into a cell array
    blocknames = blocks;
else
    for i = 1:length(blocks)
        blocknames{i} = ['B' num2str(blocks(i))];
    end
end


% Check if channels was entered; if not, default to .5s on both sides
if ~exist('channels','var') || isempty(channels)
    channels = getchannelinds([datapath filesep 'processed' filesep blocknames{1} filesep 'htkraw'],'htk'); % find channel inds
end

% Check if dataf was entered; if not, set resample flag to 0
if ~exist('dataf','var') || isempty(dataf)
    no_resample=1;
else
    no_resample=0;
end

% Check if befaft was entered; if not, default to .5s on both sides
if ~exist('befaft','var') || isempty(befaft)
    befaft=[0.5,0.5];
end

% Check if datatype was entered; if not, default to ECoG
if ~exist('datatype','var') || ~isempty(datatype)
    datatype = 'ECoG';
end

% Check if artifact was entered; if not, default to empty
if ~exist('artifact','var')
    artifact=[];
end

for i = 1:length(blocknames)
    
    % Reset evnt, out; load the next block's evnt
    evnt = []; out = [];
    load([datapath filesep 'processed' filesep blocknames{i} filesep 'evnt_' subject, '_' blocknames{i}, '.mat']);
    
    % Get names of events
    evntnames=cell(length(evnt),1);
    for j=1:length(evnt)
        evntnames{j}=evnt(j).name;
    end
    
    % [x,unique_mat,unique_index]=unique(names);
    % out=struct('name',cell(1,length(unique_mat)));
    out=struct('name',cell(1,length(evntnames)));
    
    P_Blck='  ';
    loadload;close; % loads audio colormap, filterbank, params, gets rid of resulting figure
    disp(['Processing...']);
    
    %% Loop Over Evnt
    
    for j=1:length(evnt)
        
        
        
        %     i=unique_index(cnt);       % probably here in case the list of desired entries in evnt didn't start at 1, but not currently supported
        %     i=cnt;
        if isempty(out(j).name)
            str=evnt(j).name;
            disp(['Processing sound ',num2str(j),': ',str]);
            
            % Load soundname into out structure, read audio (correct for whether .wav is included in evnt name)
            
            if strcmp(str(end-2:end),'wav') % if .wav is included in evntname
                
                soundchar=strsplit(str, {'/','.wav'}); % split string at .wav or /
                out(j).name=soundchar{end-1}; % define outname as name of sound without .wav or /
                
                % Read the audio file (with whichever function still exists for this computer)
                if exist('audioread')
                    [audio,audiof] = audioread([evnt(j).StimPath filesep evnt(j).name]);
                else
                    [audio,audiof] = wavread([evnt(j).StimPath filesep evnt(j).name]);
                end
                
                
            else % if .wav is not included in evntname
                
                out(j).name = str; % outname is the same as evntname
                
                % Read the audio file (with whichever function still exists for this computer)
                if exist('audioread')
                    [audio,audiof] = audioread([evnt(j).StimPath filesep evnt(j).name,'.wav']);
                else
                    [audio,audiof] = wavread([evnt(j).StimPath filesep evnt(j).name,'.wav']);
                end
                
            end
            
            audio = audio(:,1); % remove any extra dimensions from audio
            
            audio=[zeros(befaft(1)*audiof,1);audio;zeros(befaft(2)*audiof,1)]; % add the appropriate silence before and after the audio
            out(j).sound=audio;
            out(j).soundf=audiof;
            out(j).dataf=dataf;
            out(j).duration=evnt(j).stopTime-evnt(j).startTime+sum(befaft);
            out(j).befaft=befaft;
            out(j).type= datatype;
            out(j).resp=[];
            out(j).artifact=[];
            if isfield(evnt,'channelnames') % loads the channelnames if current evnt isn't written to contain them
                out(j).channelnames=evnt(j).channelnames;
            end
            
            switch specflag
                case 'Auditory'
                    tmpaud = wav2aud(audio, [1000/dataf 1000/dataf -2 log2(audiof/16000)] )';
                    tmpaud = AUDwrapper(audio, audiof, 0, 0);
                    
                    try
                        out(j).aud=tmpaud(:,1:round(out(j).duration*dataf));
                    catch
                        warning('Size error on line 79')
                        out(j).aud=tmpaud; % Change James: round(out(i).duration*dataf) was longer than tmpaud
                    end
                case 'mfcc'
                    out(j).mfcc=melfcc_wrapper(audio,audiof);
            end
            if abs(size(tmpaud,2)-round(out(1).duration*dataf))>1,
                warning('Size mismatch');
            end
            
            try
                out(j).aud=tmpaud(:,1:round(out(j).duration*dataf));
            catch
                warning('Size error on line 79')
                out(j).aud=tmpaud; % Change James: round(out(i).duration*dataf) was longer than tmpaud
            end
            out(j).trial=j;
        else
            out(j).trial=[out(j).trial j];
        end
        
        Blck=evnt(j).block;
        
        if Blck==P_Blck;
            
        else
            tmp = [];
            for k = 1:length(channels) % edit by Tasha; gets rid of indexing issue
                [tmp(:,k),f] = readhtk([datapath filesep 'processed' filesep Blck filesep char(cond) filesep 'Ch' num2str(channels(k)) '.htk']);
            end
            if no_resample
                record=tmp;
                dataf=f;
            else
                record=resample(tmp,dataf,round(f));
            end
            
            %%find_artifact
            tmp=[];
            for k = artifact
                [tmp(:,k),f_art] = readhtk([datapath Blck '/artifact/' num2str(k)]);
            end
            if ~isempty(artifact)
                artif_wave=downsample(tmp,round(f_art/dataf));
            end
        end
        
        P_Blck=Blck;
        
        eegstart=round((evnt(j).startTime-befaft(1))*dataf);
        newdata=record(eegstart+1:eegstart+round(out(j).duration*dataf),:)';
        out(j).resp=cat(3,out(j).resp,newdata);
        if ~isempty(artifact)
            newartifact=artif_wave(eegstart+1:eegstart+round(out(j).duration*dataf),:)';
            out(j).artifact=cat(3,out(j).artifact,newartifact);
        end
        
        
    end
    
    % Notify the block is done
    disp(['Completed ' P_Blck]);
    
    % Ask about saving
    saveevnt = input('Save out? ','s');
    if ~strcmpi(saveevnt,{'y', 'yes', '1'})
    else
        save([datapath filesep 'processed' filesep P_Blck filesep 'out_' subject, '_' P_Blck, '.mat'], 'out')
    end
end